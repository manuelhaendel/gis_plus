---
title: "Focal Statistics"
author: "Brigitte Häuser, Guilherme Arruda, Manuel Händel"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
setwd(dir = "C:/Users/Brigggi/Desktop/gis_plus/")
```

# Goal

- Create an image-filtering tool that follows the same concept as the 
Focal  Statistics  from  ArcGIS. -> Maybe an example for application for focal statistics?
- Moving window of different shapes.
- Different summary statistics.

The goal of the project was to create an image-filtering tool that follows the same concept as the 
Focal  Statistics  from  ArcGIS. --> Examples for application?  
We wanted to implement different options for both available functions as well as neighborhood types. For the functions, we use minimum, maximum, mean, standard deviation and variance. The neighborhood can have different shapes. The simplest one is a square with odd diameter, where the height is the same as the width. For odd diameters, there is a central pixel in the middle of the square. For even diameters, the middle is between two pixels. Here, the central pixel is assigned to the left resp. the top one of the possible middle pixels.   
The rectangular window has different heights and widths, but is similar to the square otherwise.  
In the circle window, the neighborhood is assigned to the pixels which have a specific distance to the central pixel. The wedge window is similar to the circle, but the user can chose to use a start and end angle, so that only a part of the circle is used.

With this options, the user has various possibilities to use the focal statistics for his own special requirements.

# Method

- Programmed in Python.
- Tried to stay close to the arc gis implementation
- Describe how the different windows get determined
- Describe what ignore_nodata does, especially concerning the edges of the array (pictures?)
- Two approaches for different neighborhoods (didn't want to discard the work, plus both work)
- Approach Rectangle (difficulties, packages, bla bla bla)

Zuerst noch ignore_nodata erklären

Due to division of labour, we have two different approaches for dealing with the border problem. One, categorising in the normal case and border cases, is applied in the square and rectangle neighorbood. For the square and wedge, we use padding. For a more detailed explanation of the two approaches see below.  

...

For the square and the rectangle neighborhood, we use two functions: "rectangfun" and "get_newdata". The first determines the window sizes from the central pixel to all four sides, which calculations differ dependend on odd or even numbers as height and width.  
Now, "get_newdata" uses informations about the window size in order to calculate the output data. For the argument ignore_nodata = True, it categorises the data into the normal case and border and corner cases, where the neighorhood shape would be bigger than the data frame. Here, it shrinks the neighborhood to the available pixels in the neighbourhood. In all cases, the statistical function is applied to the neighborhood window and the result is stored in a new data frame. If there is a NA value in the data frame, the calculation is made with the remaining.  
Is ignore_nodata = False, all pixels whose neighborhoods extend beyond the borders, are set to NA values. Besides, all pixels with NA values in their neighborhood get also NA values.
The code for the rectangle approach uses base Python and numpy.

- Approach Circle, Wedge (difficulties, packages, bla bla bla)

# Result

- Different test array.
- Showing all neighborhoods and statistics
- Should we include the debug arrays, that show the window, not the actual result?



```{python}
import numpy as np
import os

from functions import (focal_statistics, get_values,
                       get_angle, get_newdata, rectangfun)
from classes import Rectangle, Circle, Wedge

# run the focal_statistics with some example code
file = np.arange(150).reshape(15, 10)
file2 = np.arange(150).reshape(15, 10).astype(float)
file2[6, 6] = np.nan # with a NA value in the middle

print(file2)
out = focal_statistics(file, Rectangle(4,3), 'max')
print('rectang default border \n', out)

out = focal_statistics(file2, Rectangle(4,3), 'mean', ignore_nodata=False)
print('rectang ignore_nodata=FALSE with one NA value \n', out)

out = focal_statistics(file, Circle(3), "max")
print('circle default border \n', out)

out = focal_statistics(file, Wedge(3, 0, 90), "max")
print('wedge default border \n', out)


out = get_values(file, Wedge(3, 45, 180), 7, 5, show_window = 1)
print('Display window \n', out[0])
print('Display distance \n', out[1])
print('Display angle \n', out[2])
```


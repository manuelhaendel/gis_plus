---
title: "Focal Statistics"
author: "Brigitte H채user, Guilherme Arruda, Manuel H채ndel"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
setwd(dir = "C:/Users/Brigggi/Desktop/gis_plus/")
```

# Goal

- Create an image-filtering tool that follows the same concept as the 
Focal  Statistics  from  ArcGIS. -> Maybe an example for application for focal statistics?
- Moving window of different shapes.
- Different summary statistics.

The goal of the project was to create an image-filtering tool that follows the same concept as the 
Focal  Statistics  from  ArcGIS. --> Examples for application?  
Here, a statistic of the values within a specified neighbourhood for each cell position is calculated.  
We wanted to implement different options for both available functions as well as neighborhood types. For the functions, we use minimum, maximum, mean, standard deviation and variance. The neighborhood can have different shapes. The simplest one is a square with odd diameter, where the height is the same as the width. For odd diameters, there is a central pixel in the middle of the square. For even diameters, the middle is between two pixels. Here, the central pixel is assigned to the left resp. the top one of the possible middle pixels.   
The rectangular window has different heights and widths, but is similar to the square otherwise.  
In the circle window, the neighborhood is assigned to the pixels which have a specific distance to the central pixel - the radius. The wedge window is similar to the circle, but the user can choose using a start and end angle, so that only a part of the circle is used.

With this options, the user has various possibilities to use the focal statistics for his own special requirements.

# Method

- Programmed in Python.
- Tried to stay close to the arc gis implementation
- Describe how the different windows get determined
- Describe what ignore_nodata does, especially concerning the edges of the array (pictures?)
- Two approaches for different neighborhoods (didn't want to discard the work, plus both work)
- Approach Rectangle (difficulties, packages, bla bla bla)
- Approach Circle, Wedge (difficulties, packages, bla bla bla)

Border problem noch ausf체hrlicher erkl채ren oder ist das schon klar?

The project is programmed in Python. We tried so stay close to the ArcGIS implementation of focal statistics.
Due to division of labour, we have two different approaches for dealing with the border problem. One, categorising in the normal case and border cases, is applied in the square and rectangle neighorbood. For the square and wedge, we use padding. A more detailed explanation of the two approaches is below.  

...

For the square and the rectangle neighborhood, we use two functions: "rectangfun" and "get_newdata". The first determines the window sizes from the central pixel to all four sides, which calculations differ dependend on odd or even numbers as height and width. Is the width even, the central pixel is assigned to the left pixel in the middle. For a even height, the central pixel is the top pixel in the middle.  
Now, "get_newdata" uses the informations about the window size in order to calculate the output data. For the argument ignore_nodata equals true, it categorises the data into the normal case and border and corner cases, where the neighorhood shape would be bigger than the data frame. Here, it shrinks the neighborhood to the available pixels in the neighbourhood. An code example using the upper left corner:


```{r echo=TRUE, eval=FALSE}
for col in range(np.size(data, 1)):
            for row in range(np.size(data, 0)):
                
                # all corners:
                if col < wsize_left and row < wsize_top: # topleft
                    window = data[:row+wsize_bot+1, :col+wsize_right+1]
```

Here, the code iterated through all pixels in the matrix, searching for those, whose neighborhood is reaching out of the borders of the matrix. In "col < wsize_left", it is checked if the column of the pixel is smaller than the left window size of the neighorhood. If this is the case, as well as the row number of the pixel is smaller than the top window size, the code calculates the window for the upper left case.  
The data got sliced. From the very top of the matrix until the bot border of the neighborhood the rows get addressed. For the columns, the slice goes from the very left of the matrix until the right border of the neighborhood.  

In all cases, the statistical function is applied to the neighborhood window and the result is stored in a new data frame. If there is a NA value in the data frame, the calculation is made with the remaining.  
Is ignore_nodata equals false, all pixels whose neighborhoods extend beyond the borders, are set to NA values. Besides, all pixels with NA values in their neighborhood get also NA values.
The code for the rectangle approach uses base Python and numpy.



# Result

- Different test array.
- Showing all neighborhoods and statistics
- Should we include the debug arrays, that show the window, not the actual result?



```{python}
import numpy as np
import os

from functions import (focal_statistics, get_values,
                       get_angle, get_newdata, rectangfun)
from classes import Rectangle, Circle, Wedge

# run the focal_statistics with some example code
file = np.arange(150).reshape(15, 10)
file2 = np.arange(150).reshape(15, 10).astype(float)
file2[6, 6] = np.nan # with a NA value in the middle

print(file2)
out = focal_statistics(file, Rectangle(4,3), 'max')
print('rectang default border \n', out)

out = focal_statistics(file2, Rectangle(4,3), 'mean', ignore_nodata=False)
print('rectang ignore_nodata=FALSE with one NA value \n', out)

out = focal_statistics(file, Circle(3), "max")
print('circle default border \n', out)

out = focal_statistics(file, Wedge(3, 0, 90), "max")
print('wedge default border \n', out)


out = get_values(file, Wedge(3, 45, 180), 7, 5, show_window = 1)
print('Display window \n', out[0])
print('Display distance \n', out[1])
print('Display angle \n', out[2])
```

